<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>concept on Dery R Ahaddienata</title><link>https://dery.dev/tags/concept/</link><description>Recent content in concept on Dery R Ahaddienata</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 16 Jan 2022 19:08:09 +0700</lastBuildDate><atom:link href="https://dery.dev/tags/concept/index.xml" rel="self" type="application/rss+xml"/><item><title>Balancing High Level Low Level Thinking</title><link>https://dery.dev/posts/balancing-high-level-low-level-thinking/</link><pubDate>Sun, 16 Jan 2022 19:08:09 +0700</pubDate><guid>https://dery.dev/posts/balancing-high-level-low-level-thinking/</guid><description>We can&amp;rsquo;t maintain fast thinking and precise thinking at the same time. There&amp;rsquo;s a tradeoff. Let me explain, when you read a sentence, you can grasp the meaning of that sentence. But, you don&amp;rsquo;t really care about the meaning of each word, or in more precise manner, you don&amp;rsquo;t even read each alphabet. How many alphabet m you&amp;rsquo;ve read up until this point? You don&amp;rsquo;t really care right. Because, our brain has tendency to store common repeatable things (in this case, the individual word meaning or the alphabet) and only focus on the things that we think it matters (in this case, the meaning of whole sentence).</description><content>&lt;p>We can&amp;rsquo;t maintain fast thinking and precise thinking at the same time. There&amp;rsquo;s a tradeoff. Let me explain, when you read a sentence, you can grasp the meaning of that sentence. But, you don&amp;rsquo;t really care about the meaning of each word, or in more precise manner, you don&amp;rsquo;t even read each alphabet. How many alphabet &lt;code>m&lt;/code> you&amp;rsquo;ve read up until this point? You don&amp;rsquo;t really care right. Because, our brain has tendency to store common repeatable things (in this case, the individual word meaning or the alphabet) and only focus on the things that we think it matters (in this case, the meaning of whole sentence).&lt;/p>
&lt;img src="https://dery.dev/static/img/highlevel-lowlevel.png" alt="High Level &amp;amp; low level in language hierarchy" class="center" style="border-radius: 5px;" />
&lt;p>Understanding individual word meaning can be seen as a low level, and understanding the whole sentence meaning can be seen as a high level. If we only focus on each individual word meaning, our reading ability will slower than if we focus on whole sentence as it is. But you can&amp;rsquo;t know the meaning of the sentence if you&amp;rsquo;ve never understood the individual word itself. You need to be more precise when you learn something new. Are you able to understanding this sentence? 月曜日の朝. If you&amp;rsquo;re not familiar with the Japanese language, you need to learn the alphabet (hiragana, katakana, kanji), and learn the meaning of the word, and then the sentence as a whole. Let me rephrase this into more generalize concept.&lt;/p>
&lt;blockquote>
&lt;p>If we only focus on lower level task, we trade the speed over the detailed things. But if we focus on high level task before lower level, our understanding of high level is blurred. We need a balance of it. And as a software engineer, it really matters.&lt;/p>
&lt;/blockquote>
&lt;h2 id="why-is-it-important">Why is it important&lt;/h2>
&lt;p>Short answer, it&amp;rsquo;s not. But if you care about the efficiency of your time, it&amp;rsquo;s important. It will reduce the unecessary thinking if you see the things in higher level. And it will improve your ability to understand the things under the hood if you see the things in lower level. We know the abstraction. We don&amp;rsquo;t care about how the electricity give the chip gate circuit on and off while we write a program (unless you&amp;rsquo;re assembly engineer). But knowing how memory works while we write a program, can be reduce the catastrophic disaster that can be possibly happen in certain point of time.&lt;/p>
&lt;blockquote>
&lt;p>Just enough to know the low level, but think in high level abstraction.&lt;/p>
&lt;/blockquote>
&lt;h2 id="how-we-define-the-high-level-and-low-level">How we define the high level and low level&lt;/h2>
&lt;p>It depends on our role. But rule of thumb is you need to know just enough the low level that you think it matters, and think in high level to boost you productivity. If you&amp;rsquo;re a backend engineer, the low level you need to know is how OS works, and the high level thing is the code itself. If you&amp;rsquo;re an assembly engineer, maybe backend&amp;rsquo;s low level can be their high level and how the chip works can be seen as their low level thing.&lt;/p>
&lt;img src="https://dery.dev/static/img/highlevel-lowlevel-softeng.png" alt="High Level &amp;amp; low level in software engineer" class="center" style="border-radius: 5px;" />
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>We need a right balance between thinking in high level and low level. Sometimes, we need to slowdown the process if we need to understand the detail in deep, sometimes we focus only on high level without even care about the lower level (it just happens unconciously).&lt;/p></content></item><item><title>Software System Fundamentals</title><link>https://dery.dev/posts/software-system-fundamentals/</link><pubDate>Mon, 19 Jul 2021 15:49:33 +0700</pubDate><guid>https://dery.dev/posts/software-system-fundamentals/</guid><description>The book I&amp;rsquo;m currently reading is Designing Data Intensive Applications by Martin Kleppmann. During the first read, I found concise fundamentals we need to concern most when dealing with a high quality software system. There&amp;rsquo;re 3 fundamentals as follow:
Fundamental Definition Reliability The system should work properly even when the things go wrong (faulty) Scalability The system should be able to handle the growth (data volume, traffic, or complexity) Maintainability The system should easily adaptable enough during maintenance (bugs, failures, and new features) Reliability Faulty can come up from several places:</description><content>&lt;p>The book I&amp;rsquo;m currently reading is &lt;a href="https://learning.oreilly.com/library/view/designing-data-intensive-applications/9781491903063/">Designing Data Intensive Applications&lt;/a> by Martin Kleppmann. During the first read, I found concise fundamentals we need to concern most when dealing with a high quality software system. There&amp;rsquo;re 3 fundamentals as follow:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Fundamental&lt;/th>
&lt;th>Definition&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Reliability&lt;/strong>&lt;/td>
&lt;td>The system should work properly even when the things go wrong (faulty)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Scalability&lt;/strong>&lt;/td>
&lt;td>The system should be able to handle the growth (data volume, traffic, or complexity)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Maintainability&lt;/strong>&lt;/td>
&lt;td>The system should easily adaptable enough during maintenance (bugs, failures, and new features)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="reliability">Reliability&lt;/h2>
&lt;p>Faulty can come up from several places:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Hardware Faults&lt;/strong>: eg. Hard disk has MTTF (mean time to failure) of about 10 to 50 years.&lt;/li>
&lt;li>&lt;strong>Software Faults&lt;/strong>: eg. Uncaught bugs in Linux kernel due to leap second on June 20, 2012.&lt;/li>
&lt;li>&lt;strong>Human Errors&lt;/strong>: eg. Configuration error by operators leads the most system outage.&lt;/li>
&lt;/ul>
&lt;h2 id="scalability">Scalability&lt;/h2>
&lt;p>Data growth is equal to increasing load. There&amp;rsquo;re 2 things need to describe:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Load&lt;/strong>: current load existing on the system. Some parameters:
&lt;ul>
&lt;li>request per second&lt;/li>
&lt;li>response time&lt;/li>
&lt;li>read write ration on DB&lt;/li>
&lt;li>number of concurrent user&lt;/li>
&lt;li>hit rate on cache&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Performance&lt;/strong>: metrics that used to define how good the system handle load. It can be used as SLA / SLO. Some metrics:
&lt;ul>
&lt;li>avg / mean&lt;/li>
&lt;li>median: p50&lt;/li>
&lt;li>percentile: p95, p99, p999&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="maintainability">Maintainability&lt;/h2>
&lt;p>The goal is to minimize pain during maintenance. Three design principles need to follow:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Operability&lt;/strong>: make it easy for teams to keep the system run smoothly.&lt;/li>
&lt;li>&lt;strong>Simplicity&lt;/strong>: make it easy for new engineer to understand the system.&lt;/li>
&lt;li>&lt;strong>Evolvability&lt;/strong>: make it easy for engineer to extend the system.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>References&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://learning.oreilly.com/library/view/designing-data-intensive-applications/9781491903063/">Designing Data Intensive Applications&lt;/a> by Martin Kleppmann&lt;/li>
&lt;/ol></content></item></channel></rss>