<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>concept on Dery R Ahaddienata</title><link>https://dery.dev/tags/concept/</link><description>Recent content in concept on Dery R Ahaddienata</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 30 Apr 2023 19:44:09 +0700</lastBuildDate><atom:link href="https://dery.dev/tags/concept/index.xml" rel="self" type="application/rss+xml"/><item><title>Thinking in Moderation</title><link>https://dery.dev/posts/thinking-in-moderation/</link><pubDate>Sun, 30 Apr 2023 19:44:09 +0700</pubDate><guid>https://dery.dev/posts/thinking-in-moderation/</guid><description>In Moderation :in a way that is reasonable and not excessive :in a moderate way - Merriam-Webster
You will die if you don’t eat, and you will die either if you eat excessively. In the Nicomachean Ethics, Aristotle describes that eating too much or too little has a bad consequences to our body. Hence, the correlation between eating and health is not linear.
In economics, no tax makes government has no revenue, no infrastructure, public health, education, and security.</description><content>&lt;blockquote>
&lt;p>In Moderation :in a way that is reasonable and not excessive :in a moderate way - Merriam-Webster&lt;/p>
&lt;/blockquote>
&lt;p>You will die if you don’t eat, and you will die either if you eat excessively. In the Nicomachean Ethics, Aristotle describes that eating too much or too little has a bad consequences to our body. Hence, the correlation between eating and health is not linear.&lt;/p>
&lt;p>In economics, no tax makes government has no revenue, no infrastructure, public health, education, and security. On the other side, charged 100% tax makes individual has no money, and there’s no reason to work, then economy collapse and government has no revenue. It’s clear that the government’s revenue and taxation is not linear either.&lt;/p>
&lt;img src="https://dery.dev/static/img/non-linear.png" alt="Linear vs Laffer Curve" class="center" style="border-radius: 5px;" />
&lt;p>In finance management, too much saving habit for retirement makes latter regret of not spent your youthful spending money for your own good. But excessively spending money makes you regret as well for not having retirement saving. Correlation between regretlessness and saving for retirement is not linear.&lt;/p>
&lt;p>In software development, there’s always tradeoff, there’s always an opportunity cost on choosing between one approach besides another. Which one is better, build a bugs free solution but late delivery. Or build a simple, one day delivery but bugs are everywhere. The relation between the quality of being professional and the time taken to develop software with less bugs is also not linear.&lt;/p>
&lt;p>It&amp;rsquo;s always naive to have a linear mindset. The world is not made in binary characteristic, linear correlation. There’s a lot example of it, I just only mention few. If there&amp;rsquo;s an optimal way, it must be somewhere in between. And it applies on every aspects.&lt;/p>
&lt;blockquote>
&lt;p>Thinking in moderation means thinking in a way that nothing can be called as an optimal unless we believe that the extreme must not the answer of the optimal solution.&lt;/p>
&lt;/blockquote></content></item><item><title>Balancing High Level Low Level Thinking</title><link>https://dery.dev/posts/balancing-high-level-low-level-thinking/</link><pubDate>Sun, 16 Jan 2022 19:08:09 +0700</pubDate><guid>https://dery.dev/posts/balancing-high-level-low-level-thinking/</guid><description>We can&amp;rsquo;t maintain fast thinking and precise thinking at the same time. There&amp;rsquo;s a tradeoff. Let me explain, when you read a sentence, you can grasp the meaning of that sentence. But, you don&amp;rsquo;t really care about the meaning of each word, or in more precise manner, you don&amp;rsquo;t even read each alphabet. How many alphabet m you&amp;rsquo;ve read up until this point? You don&amp;rsquo;t really care right? Because, our brain has tendency to automate common repeatable things (in this case, the individual word meaning or the alphabet) and only focus on the things that we think it matters (in this case, the meaning of whole sentence).</description><content>&lt;p>We can&amp;rsquo;t maintain fast thinking and precise thinking at the same time. There&amp;rsquo;s a tradeoff. Let me explain, when you read a sentence, you can grasp the meaning of that sentence. But, you don&amp;rsquo;t really care about the meaning of each word, or in more precise manner, you don&amp;rsquo;t even read each alphabet. How many alphabet &lt;code>m&lt;/code> you&amp;rsquo;ve read up until this point? You don&amp;rsquo;t really care right? Because, our brain has tendency to automate common repeatable things (in this case, the individual word meaning or the alphabet) and only focus on the things that we think it matters (in this case, the meaning of whole sentence).&lt;/p>
&lt;img src="https://dery.dev/static/img/highlevel-lowlevel.png" alt="High Level &amp;amp; low level in language hierarchy" class="center" style="border-radius: 5px;" />
&lt;p>Understanding individual word meaning can be seen as a low level, and understanding the whole sentence meaning can be seen as a high level. If we only focus on each individual word meaning, our reading ability will slower than if we focus on whole sentence as it is. But you can&amp;rsquo;t know the meaning of the sentence if you&amp;rsquo;ve never understood the individual word itself. You need to be more precise when you learn something new.&lt;/p>
&lt;p>Are you able to understand this sentence? 月曜日の朝. If you&amp;rsquo;re not familiar with the Japanese language, you need to learn the alphabet (hiragana, katakana, kanji), and learn the meaning of the word, and then the sentence as a whole. Let me rephrase this into more generalize concept. If we only focus on lower level task, we trade the ability to know detailed things over the speed. But if we focus on high level task before lower level, our understanding of high level is blurred. We need a balance of it. And as a software engineer, it really matters.&lt;/p>
&lt;blockquote>
&lt;p>If we only focus on lower level task, we trade the ability to know detailed things over the speed. But if we focus on high level task before lower level, our understanding of high level is blurred. We need a balance of it.&lt;/p>
&lt;/blockquote>
&lt;h2 id="why-is-it-important">Why is it important&lt;/h2>
&lt;p>Short answer, it&amp;rsquo;s not. But if you care about the efficiency of your time, it&amp;rsquo;s important. It will reduce the unecessary thinking if you see the things in higher level. And it will improve your ability to understand the things under the hood if you see the things in lower level. We know the abstraction. Each level has abstraction of its lower level. We don&amp;rsquo;t care about how the electricity give the chip gate circuit on and off (low level) while we write a program (high level) (unless you&amp;rsquo;re assembly engineer 😄). But knowing how memory works (low level) while we write a program (high level), can be reduce the catastrophic disaster that can be possibly happen in certain point of time.&lt;/p>
&lt;h2 id="how-we-define-the-high-level-and-low-level">How we define the high level and low level&lt;/h2>
&lt;p>It depends. But rule of thumb is you need to know just enough the low level that you think it matters, and think in high level to boost you speed. If you&amp;rsquo;re a backend engineer, the low level you need to know is how OS works, and the high level thing is the code itself. If you&amp;rsquo;re an assembly engineer, maybe backend&amp;rsquo;s low level can be seen as their high level and how the chip works can be seen as their low level thing.&lt;/p>
&lt;blockquote>
&lt;p>Just enough to know the low level concept, but think in high level abstraction.&lt;/p>
&lt;/blockquote>
&lt;img src="https://dery.dev/static/img/highlevel-lowlevel-softeng.png" alt="High Level &amp;amp; low level in software engineer" class="center" style="border-radius: 5px;" />
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>We need a right balance between thinking in high level and low level. Sometimes, we need to slowdown the process if we need to understand the detail in deep, sometimes we need to focus only on high level without even care about the lower level (it just happens unconciously). By balancing both dynamically in a certain short of condition, we are able to utilize the advantages from both combination.&lt;/p></content></item><item><title>Software System Fundamentals</title><link>https://dery.dev/posts/software-system-fundamentals/</link><pubDate>Mon, 19 Jul 2021 15:49:33 +0700</pubDate><guid>https://dery.dev/posts/software-system-fundamentals/</guid><description>The book I&amp;rsquo;m currently reading is Designing Data Intensive Applications by Martin Kleppmann. During the first read, I found concise fundamentals we need to concern most when dealing with a high quality software system. There&amp;rsquo;re 3 fundamentals as follow:
Fundamental Definition Reliability The system should work properly even when the things go wrong (faulty) Scalability The system should be able to handle the growth (data volume, traffic, or complexity) Maintainability The system should easily adaptable enough during maintenance (bugs, failures, and new features) Reliability Faulty can come up from several places:</description><content>&lt;p>The book I&amp;rsquo;m currently reading is &lt;a href="https://learning.oreilly.com/library/view/designing-data-intensive-applications/9781491903063/">Designing Data Intensive Applications&lt;/a> by Martin Kleppmann. During the first read, I found concise fundamentals we need to concern most when dealing with a high quality software system. There&amp;rsquo;re 3 fundamentals as follow:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Fundamental&lt;/th>
&lt;th>Definition&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Reliability&lt;/strong>&lt;/td>
&lt;td>The system should work properly even when the things go wrong (faulty)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Scalability&lt;/strong>&lt;/td>
&lt;td>The system should be able to handle the growth (data volume, traffic, or complexity)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Maintainability&lt;/strong>&lt;/td>
&lt;td>The system should easily adaptable enough during maintenance (bugs, failures, and new features)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="reliability">Reliability&lt;/h2>
&lt;p>Faulty can come up from several places:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Hardware Faults&lt;/strong>: eg. Hard disk has MTTF (mean time to failure) of about 10 to 50 years.&lt;/li>
&lt;li>&lt;strong>Software Faults&lt;/strong>: eg. Uncaught bugs in Linux kernel due to leap second on June 20, 2012.&lt;/li>
&lt;li>&lt;strong>Human Errors&lt;/strong>: eg. Configuration error by operators leads the most system outage.&lt;/li>
&lt;/ul>
&lt;h2 id="scalability">Scalability&lt;/h2>
&lt;p>Data growth is equal to increasing load. There&amp;rsquo;re 2 things need to describe:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Load&lt;/strong>: current load existing on the system. Some parameters:
&lt;ul>
&lt;li>request per second&lt;/li>
&lt;li>response time&lt;/li>
&lt;li>read write ration on DB&lt;/li>
&lt;li>number of concurrent user&lt;/li>
&lt;li>hit rate on cache&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Performance&lt;/strong>: metrics that used to define how good the system handle load. It can be used as SLA / SLO. Some metrics:
&lt;ul>
&lt;li>avg / mean&lt;/li>
&lt;li>median: p50&lt;/li>
&lt;li>percentile: p95, p99, p999&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="maintainability">Maintainability&lt;/h2>
&lt;p>The goal is to minimize pain during maintenance. Three design principles need to follow:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Operability&lt;/strong>: make it easy for teams to keep the system run smoothly.&lt;/li>
&lt;li>&lt;strong>Simplicity&lt;/strong>: make it easy for new engineer to understand the system.&lt;/li>
&lt;li>&lt;strong>Evolvability&lt;/strong>: make it easy for engineer to extend the system.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>References&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://learning.oreilly.com/library/view/designing-data-intensive-applications/9781491903063/">Designing Data Intensive Applications&lt;/a> by Martin Kleppmann&lt;/li>
&lt;/ol></content></item></channel></rss>