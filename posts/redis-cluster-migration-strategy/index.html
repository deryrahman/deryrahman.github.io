<!doctype html><html lang=en><head><title>Redis Cluster Migration Strategy :: Dery R Ahaddienata</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Last week I have a chance to perform Redis cluster migration. Our Redis cluster contains 6 high memory VMs. At peak, it has 800 request/second. In this article I would like to explain how we migrate Redis cluster with zero downtime as well as lesson learned I&amp;rsquo;ve gathered.
Problem Statement As Ubuntu 16.04 no longer support LTS, we need to upgrade some obsolete VMs to latest version (20.04). One of the obsolete VMs are our Redis cluster."><meta name=keywords content="redis,migration,cluster,strategy"><meta name=robots content="noodp"><link rel=canonical href=https://deryrahman.github.io/posts/redis-cluster-migration-strategy/><link rel=stylesheet href=https://deryrahman.github.io/assets/style.css><link rel=apple-touch-icon href=https://deryrahman.github.io/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://deryrahman.github.io/img/favicon/orange.png><meta name=twitter:card content="summary"><meta name=twitter:site content="deryrahman"><meta name=twitter:creator content="deryrahman"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Redis Cluster Migration Strategy"><meta property="og:description" content="Last week I have a chance to perform Redis cluster migration. Our Redis cluster contains 6 high memory VMs. At peak, it has 800 request/second. In this article I would like to explain how we migrate Redis cluster with zero downtime as well as lesson learned I&amp;rsquo;ve gathered.
Problem Statement As Ubuntu 16.04 no longer support LTS, we need to upgrade some obsolete VMs to latest version (20.04). One of the obsolete VMs are our Redis cluster."><meta property="og:url" content="https://deryrahman.github.io/posts/redis-cluster-migration-strategy/"><meta property="og:site_name" content="Dery R Ahaddienata"><meta property="og:image" content="https://deryrahman.github.io"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2021-07-17 23:16:48 +0700 +0700"></head><body class=orange><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>deryrahman@github.io:~#</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about>About</a></li><li><a href=/pillars-principles>Pillars & Principles</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about>About</a></li><li><a href=/pillars-principles>Pillars & Principles</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://deryrahman.github.io/posts/redis-cluster-migration-strategy/>Redis Cluster Migration Strategy</a></h1><div class=post-meta><span class=post-date>2021-07-17</span>
<span class=post-author>:: Dery R Ahaddienata</span></div><span class=post-tags>#<a href=https://deryrahman.github.io/tags/tech/>tech</a>&nbsp;
#<a href=https://deryrahman.github.io/tags/storage/>storage</a>&nbsp;
#<a href=https://deryrahman.github.io/tags/redis/>redis</a>&nbsp;</span><div class=table-of-contents><h2>Table of Contents</h2><nav id=TableOfContents><ul><li><a href=#problem-statement>Problem Statement</a></li><li><a href=#goal>Goal</a></li><li><a href=#approach>Approach</a></li><li><a href=#lesson-learned>Lesson Learned</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div><div class=post-content><div><p>Last week I have a chance to perform Redis cluster migration. Our Redis cluster contains 6 high memory VMs. At peak, it has 800 request/second. In this article I would like to explain how we migrate Redis cluster with zero downtime as well as lesson learned I&rsquo;ve gathered.</p><h2 id=problem-statement>Problem Statement<a href=#problem-statement class=hanchor arialabel=Anchor>&#8983;</a></h2><p>As Ubuntu 16.04 no longer support LTS, we need to upgrade some obsolete VMs to latest version (20.04). One of the obsolete VMs are our Redis cluster. Most of the services rely on our service that use this Redis cluster as in-memory storage. Upgrading the OS inside the node is not the option since it require complex reconfiguration as well as inevitable downtime.</p><p>We&rsquo;re using Redis version 5.0.9, with GCP VM n2-highmem-4. The cluster contains 3 master nodes and 3 slave nodes. The keys are stored in memory that filled up 16GB across 3 partitions.</p><h2 id=goal>Goal<a href=#goal class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Upgrade the Ubuntu version (16.04) of all Redis cluster nodes to 20.14 with zero downtime.</p><h2 id=approach>Approach<a href=#approach class=hanchor arialabel=Anchor>&#8983;</a></h2><p>First we spin up new GCP VM with Ubuntu 20.04 installed. Then install and configure the Redis so that this new Redis are ready to join to the existing cluster. Then add this node to the cluster as a slave of partition 1. Wait for this slave to sync the data with the master. Repeat it for the partition 2 and 3. Then perform manual failover so the new node will be promoted as a new master. Finally, detach all the old Redis nodes from cluster. It seems like quite easy. Yes it does. But in practice, we have a challenge. The challenge will be explained in the <a href=#lesson-learned>Lesson Learned</a> section.</p><p>Put image here (TBD)</p><p>Here&rsquo;re some steps in details:</p><ol><li>Spin up new GCP VM. I won&rsquo;t explain how to do that since it&rsquo;s out of scope from our topic.</li><li>Configure Redis 5.0.9 to meet minimum requirement as a node cluster. All configuration can be seen <a href=https://redis.io/topics/cluster-tutorial>here</a>.<div class=collapsable-code><input id=1 type=checkbox>
<label for=1><span class=collapsable-code__language>conf</span>
<span class=collapsable-code__title>redis.conf</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-conf><code>
    cluster-node-timeout 100
    cluster-enabled yes
    cluster-config-file &#34;auto-nodes.conf&#34;
    cluster-replica-validity-factor 1
    cluster-require-full-coverage no
    aof-use-rdb-preamble yes
    </code></pre></div></li><li>Add the new node to the existing cluster as a slave. Wait for this new node to perform full sync with master. We have 3 node partitions, make sure this new node will join as a slave of corresponding master.<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>redis-cli --cluster add-node &lt;new_redis_box_ip&gt;:6379 &lt;any_old_redis_box_ip&gt;:6379 --cluster-slave --cluster-master-id &lt;master_id&gt;

</code></pre></div></li><li>Repeat step 1-3 for each partitions. The result, there&rsquo;re 2 new slaves for each partition. Total nodes in cluster is 12, 6 old nodes, other 6 are new nodes.</li><li><a href=https://redis.io/commands/cluster-failover>Failover</a> the old master and promote new node as a master for each partitions.<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>redis-cli -h &lt;new_redis_box_ip&gt; -p <span style=color:#ae81ff>6379</span>
<span style=color:#75715e># run redis-cli command: CLUSTER FAILOVER</span>
</code></pre></div></li><li>Detach 6 old nodes from the cluster.<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>redis-cli --cluster del-node &lt;new_redis_box_ip&gt;:6379 &lt;old_node_id&gt;

</code></pre></div></li></ol><h2 id=lesson-learned>Lesson Learned<a href=#lesson-learned class=hanchor arialabel=Anchor>&#8983;</a></h2><p>When we do step 3, there&rsquo;s a huge missing read request. After we seek for the root cause it happens because during full sync, ~5GB data transfer from master to new slave, the new slave will fill up the huge data to memory from disk. This activity leads to high CPU usage on our new slave node. Thus, some request that read data from this slave would not be proceeded.</p><p>Before that, we also suspect it&rsquo;s because of the fork process during RDB backup on the master. Redis cluster use RDB file to sync with the replica. And yup, fork process on Redis would consume huge CPU. But if this is the cause, it could be the issue for a long time ago, since the sync process between master and slave is always happening.</p><p>Second suspect is <a href=https://github.com/redis/redis/issues/4815>due to bandwidth limit</a>. During full sync process, master and slave will transfer the data as fast as possible so that the bandwidth is reach its limit. Hence, it will cause the request blocking. But, after we saw from our monitoring tool, we didn&rsquo;t see any request error when master was transfering data to the new slave.</p><p>The request was blocked when new slave fill up the new data. It happened so fast so that the CPU usage was 100%. Some requests that read from this new slave was failing. We still didn&rsquo;t know and the inner process how the Redis fill up memory from zero. We also seek for a solution to hold the Redis read from specific slave, but we didn&rsquo;t see any configuration to configure this. The close possible solution is <code>cluster-allow-reads-when-down</code>, but it&rsquo;s for redis 6.0. We didn&rsquo;t have time to explore this deeper.</p><p>Thus we planned to do this migration during off hour.</p><h2 id=conclusion>Conclusion<a href=#conclusion class=hanchor arialabel=Anchor>&#8983;</a></h2><p>We&rsquo;re fail to do Redis cluster migration with zero downtime. But, we know for sure that this strategy is worked when data it not big. We performed the Redis cluster migration on integration, and we achieved zero error and zero downtime. Perhaps, if we can block the Redis read on the new slave, it might probably help when the new slave perform a full sync from master node.</p><p><strong>References</strong></p><ol><li><a href=https://redis.io/topics/cluster-tutorial>https://redis.io/topics/cluster-tutorial</a></li><li><a href=https://redis.io/commands/cluster-failover>https://redis.io/commands/cluster-failover</a></li><li><a href=https://github.com/redis/redis/issues/4815>https://github.com/redis/redis/issues/4815</a></li></ol></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://deryrahman.github.io/posts/software-system-fundamentals/><span class=button__icon>←</span>
<span class=button__text>Software System Fundamentals</span></a></span>
<span class="button next"><a href=https://deryrahman.github.io/posts/working-setup/><span class=button__text>Working Setup</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2021 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://deryrahman.github.io/assets/main.js></script><script src=https://deryrahman.github.io/assets/prism.js></script></div></body></html>